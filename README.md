# RabbitMQ
使用C++仿造 RabbitMQ 实现消息队列

[toc]

# 开发环境
- Linux（ubuntu22.04）
- g++/gdb
- CMake

# 技术选型
- 序列化框架：Protobuf
- 网络通信：自定义应用层协议+muduo库
- 源数据信息数据库：SQLite3
- 单元测试框架：Gtest

## 线程池工作思想
- 用户传入要执行的函数，以及需要处理的数据（函数的参数），由线程池中的工作线程来执行函数完成任务

实现：
- 管理的成员
- - 任务池：用vector维护的一个函数任务池
- - 互斥锁 & 条件变量：实现同步互斥
- - 一定数量的工作线程：用于不断从任务池取出任务执行任务
- - 结束运行标志：以便于控制线程池的结束
- 管理的操作：
- - 入队任务：入队一个函数和参数
- - 停止运行：终止线程池


## 目录结构
- test/demo：编写一些功能用例时所在的目录
- mqcommon：公共模块代码（线程池、数据库访问、文件访问、日志打印、pd相关，以及其他的一些琐碎功能模块代码
- mqclient：客户端模块代码
- mqserver：服务器模块代码
- mqtest：单元测试
- third：用到的第三方库存放目录

## 核心模块实现
### 1、日志打印工具
>为了便于编写项目中能够快速定位程序的错误位置

### 2、实用Helper工具
>Helper工具类中要完成的是项目中需要的一些辅助零碎的功能代码实现，其中包括文件的基础操作，字符串的额外操作等在项目中用到的零碎功能（在demo样例中有注释实现）
#### 2.1、文件基础操作
- 文件是否存在判断
- 文件大小获取
- 文件读写
- 文件创建/删除
- 目录创建/删除

#### 2.2、sqlite基础操作类
- 判断库是否存在
- 创建并打开库/关闭库/删除库
- 启动/提交/回滚事务
- 执行语句

#### 2.3、字符串操作类
- 提供字符串分割功能

#### 2.4、UUID生成器类
>UUID(Universally Unique Identifier)，也叫**通用唯一识别码**，通常由32位16进制数字字符组成
UUID的标准形式包含32个16进制数字，以连字号分为5段，形式为8-4-4-4-12的32个字符，如：550e840-e29b-41d4-a715-446655440000

在这里，uuid生成，我们采用生成8个随机数字（0～255，一个字节8位），加上8字节序号，共16字节数组生成32位16进制字符（4位）的组合形式来确保全局唯一的同时能够根据序号来分辨数据
- 随机数的生成 `random_device`


### 消息类型定义&交换机类型定义
1. 消息所需要素
    1. 消息本身要素
        1. 消息属性：消息属性中包含有以下内容
            - 消息ID
            - 消息投递模式：非持久化模式/持久化模式
            - 消息的routing_key
        2. 消息有效载荷内容
    2. 消息额外存储所需要素
        1. 消息的存储位置
        2. 消息的长度
        3. 消息是否有效：注意这里并不使用bool类型，而是使用字符的0/1，因为bool类型在持久化的时候所占长度不同，会导致修改文件中消息有效位后消息长度发生变化，因此不用bool类型
因为客户端与服务端都会用到交换机的一些相关信息，比如交换机类型，还有就是消息的持久化模式，因此将交换机类型的枚举，与消息投递模式的枚举也顺便同时定义到proto文件中
1. 交换机类型
    1. DIRECT
    2. FANOUT
    3. TOPIC
2. 消息投递模式
    1. UNDURABLE：在RabbitMQ中，此模式的值为1
    2. DURABLE：值为2

### 交换机数据管理
1. 定义交换机数据类
    1. 交换机名称
    2. 交换机类型
    3. 是否持久化标志
    4. 是否自动删除标识
    5. 其他参数
2. 定义交换机数据持久化类（数据持久化的sqlite3数据库中）
    1. 声明/删除交换机数据表
    2. 新增交换机数据
    3. 移除交换机数据
    4. 查询所有交换机数据
    5. 查询指定交换机数据（根据名称）
3. 定义交换机数据管理类
    1. 声明交换机，并添加管理（存在则OK，不存在则创建）
    2. 删除交换机
    3. 获取指定交换机
    4. 销毁所有交换机数据

    



